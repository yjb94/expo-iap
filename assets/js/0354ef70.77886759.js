"use strict";(self.webpackChunkexpo_iap_docs=self.webpackChunkexpo_iap_docs||[]).push([[7031],{571:(e,n,s)=>{s.d(n,{A:()=>c});var r=s(6540),i=s(4848);function t({className:e="adfit",style:n,unit:s,height:t,width:c}){return(0,r.useEffect)(()=>{const n=setTimeout(()=>{const n=document.querySelector(`.${e}`);if(!n)return void console.warn(`AdFit: Element with class "${e}" not found`);const r=n.querySelectorAll(".kakao_ad_area"),i=n.querySelectorAll('script[src*="kas/static/ba.min.js"]');r.forEach(e=>e.remove()),i.forEach(e=>e.remove());const o=document.createElement("ins"),a=document.createElement("script");o.className="kakao_ad_area",o.style.cssText="display:none; width:100%;",a.async=!0,a.type="text/javascript",a.src="//t1.daumcdn.net/kas/static/ba.min.js",o.setAttribute("data-ad-width",c.toString()),o.setAttribute("data-ad-height",t.toString()),o.setAttribute("data-ad-unit",s),n.appendChild(o),n.appendChild(a)},100);return()=>clearTimeout(n)},[e,s,t,c]),(0,i.jsx)("div",{style:n,children:(0,i.jsx)("div",{className:e})})}function c(){return(0,i.jsx)(t,{unit:"DAN-YTmjDwlbcP42HBg6",height:100,width:320,className:"adfit-top",style:{flex:1,marginTop:24,marginBottom:24}})}},3493:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"guides/lifecycle","title":"Lifecycle","description":"Understanding the lifecycle of in-app purchase connections and how to properly manage them is crucial for a robust implementation.","source":"@site/versioned_docs/version-2.6/guides/lifecycle.md","sourceDirName":"guides","slug":"/guides/lifecycle","permalink":"/docs/2.6/guides/lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/expo-iap/tree/main/docs/versioned_docs/version-2.6/guides/lifecycle.md","tags":[],"version":"2.6","sidebarPosition":4,"frontMatter":{"title":"Lifecycle","sidebar_label":"Lifecycle","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Purchases","permalink":"/docs/2.6/guides/purchases"},"next":{"title":"Offer Code Redemption","permalink":"/docs/2.6/guides/offer-code-redemption"}}');var i=s(4848),t=s(8453),c=s(571);const o={title:"Lifecycle",sidebar_label:"Lifecycle",sidebar_position:4},a="Lifecycle",l={},d=[{value:"Lifecycle Overview",id:"lifecycle-overview",level:2},{value:"Connection Management with useIAP",id:"connection-management-with-useiap",level:2},{value:"Automatic Connection",id:"automatic-connection",level:3},{value:"Connection States",id:"connection-states",level:3},{value:"Component Lifecycle Integration",id:"component-lifecycle-integration",level:2},{value:"Class Components",id:"class-components",level:3},{value:"Functional Components",id:"functional-components",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 Do:",id:"-do",level:3},{value:"\u274c Don&#39;t:",id:"-dont",level:3},{value:"Purchase Flow Best Practices",id:"purchase-flow-best-practices",level:2},{value:"Receipt Validation and Security",id:"receipt-validation-and-security",level:3},{value:"Purchase State Management",id:"purchase-state-management",level:3},{value:"Error Handling and User Experience",id:"error-handling-and-user-experience",level:3},{value:"Testing and Development",id:"testing-and-development",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"Transaction Management Issues",id:"transaction-management-issues",level:3},{value:"Security Issues",id:"security-issues",level:3},{value:"Development and Testing Issues",id:"development-and-testing-issues",level:3},{value:"App Lifecycle Issues",id:"app-lifecycle-issues",level:3},{value:"Connection Management Issues",id:"connection-management-issues",level:3},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lifecycle",children:"Lifecycle"})}),"\n",(0,i.jsx)(c.A,{}),"\n",(0,i.jsx)(n.p,{children:"Understanding the lifecycle of in-app purchase connections and how to properly manage them is crucial for a robust implementation."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Lifecycle Diagram",src:s(8028).A+"",width:"1154",height:"989"})}),"\n",(0,i.jsx)(n.h2,{id:"lifecycle-overview",children:"Lifecycle Overview"}),"\n",(0,i.jsx)(n.p,{children:"The diagram above illustrates the complete lifecycle of in-app purchases in expo-iap:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialization"}),": Connection to the store is established"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Product Fetching"}),": Available products are retrieved from the store"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purchase Request"}),": User initiates a purchase"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purchase Processing"}),": The store processes the payment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purchase Update"}),": Your app receives purchase notifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation"}),": Receipt validation (should be done server-side)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transaction Finishing"}),": Complete the transaction to finalize the purchase"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Management"}),": Proper cleanup when needed"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"connection-management-with-useiap",children:"Connection Management with useIAP"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"useIAP"})," hook automatically manages the connection lifecycle for you, but it's important to understand what happens under the hood."]}),"\n",(0,i.jsx)(n.h3,{id:"automatic-connection",children:"Automatic Connection"}),"\n",(0,i.jsxs)(n.p,{children:["When you use the ",(0,i.jsx)(n.code,{children:"useIAP"})," hook, it automatically:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Initializes the connection to the store"}),"\n",(0,i.jsx)(n.li,{children:"Sets up purchase listeners"}),"\n",(0,i.jsx)(n.li,{children:"Manages connection state"}),"\n",(0,i.jsx)(n.li,{children:"Cleans up when the component unmounts"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {useIAP} from 'expo-iap';\n\nexport default function App() {\n  const {connected, products, getProducts} = useIAP();\n\n  useEffect(() => {\n    // Connection is automatically established\n    if (connected) {\n      console.log('Connected to store');\n      // You can now safely call store methods\n      getProducts({skus: ['product1', 'product2']});\n    }\n  }, [connected, getProducts]);\n\n  return <YourAppContent />;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"connection-states",children:"Connection States"}),"\n",(0,i.jsx)(n.p,{children:"The connection can be in several states:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disconnected"}),": Initial state, no connection to store"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connecting"}),": Attempting to establish connection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connected"}),": Successfully connected, ready for operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error"}),": Connection failed"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'const {connected, connectionError} = useIAP();\n\nif (connectionError) {\n  return <ErrorView error={connectionError} />;\n}\n\nif (!connected) {\n  return <LoadingView message="Connecting to store..." />;\n}\n\nreturn <StoreView />;\n'})}),"\n",(0,i.jsx)(n.h2,{id:"component-lifecycle-integration",children:"Component Lifecycle Integration"}),"\n",(0,i.jsx)(n.h3,{id:"class-components",children:"Class Components"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import React, {Component} from 'react';\nimport {\n  initConnection,\n  endConnection,\n  purchaseUpdatedListener,\n  purchaseErrorListener,\n} from 'expo-iap';\n\nclass StoreComponent extends Component {\n  purchaseUpdateSubscription = null;\n  purchaseErrorSubscription = null;\n\n  async componentDidMount() {\n    try {\n      await initConnection();\n\n      // Set up purchase listeners\n      this.purchaseUpdateSubscription = purchaseUpdatedListener((purchase) => {\n        this.handlePurchaseUpdate(purchase);\n      });\n\n      this.purchaseErrorSubscription = purchaseErrorListener((error) => {\n        this.handlePurchaseError(error);\n      });\n    } catch (error) {\n      console.error('Failed to initialize:', error);\n    }\n  }\n\n  componentWillUnmount() {\n    // Clean up listeners\n    if (this.purchaseUpdateSubscription) {\n      this.purchaseUpdateSubscription.remove();\n    }\n\n    if (this.purchaseErrorSubscription) {\n      this.purchaseErrorSubscription.remove();\n    }\n\n    // End connection\n    endConnection();\n  }\n\n  handlePurchaseUpdate = (purchase) => {\n    // Handle purchase updates\n  };\n\n  handlePurchaseError = (error) => {\n    // Handle purchase errors\n  };\n\n  render() {\n    return <div>Your store UI</div>;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"functional-components",children:"Functional Components"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import React, {useEffect, useRef} from 'react';\nimport {\n  initConnection,\n  endConnection,\n  purchaseUpdatedListener,\n  purchaseErrorListener,\n} from 'expo-iap';\n\nexport default function StoreComponent() {\n  const listenersRef = useRef([]);\n\n  useEffect(() => {\n    const setupStore = async () => {\n      try {\n        await initConnection();\n\n        // Set up listeners\n        const purchaseUpdateSubscription = purchaseUpdatedListener(\n          (purchase) => {\n            handlePurchaseUpdate(purchase);\n          },\n        );\n\n        const purchaseErrorSubscription = purchaseErrorListener((error) => {\n          handlePurchaseError(error);\n        });\n\n        // Store references for cleanup\n        listenersRef.current = [\n          purchaseUpdateSubscription,\n          purchaseErrorSubscription,\n        ];\n      } catch (error) {\n        console.error('Failed to setup store:', error);\n      }\n    };\n\n    setupStore();\n\n    // Cleanup function\n    return () => {\n      // Remove listeners\n      listenersRef.current.forEach((subscription) => {\n        if (subscription && subscription.remove) {\n          subscription.remove();\n        }\n      });\n\n      // End connection\n      endConnection();\n    };\n  }, []);\n\n  const handlePurchaseUpdate = (purchase) => {\n    // Handle purchase updates\n  };\n\n  const handlePurchaseError = (error) => {\n    // Handle purchase errors\n  };\n\n  return <div>Your store UI</div>;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"-do",children:"\u2705 Do:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use useIAP hook"}),": Simplifies lifecycle management"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialize early"}),": Connect to store as early as possible in app lifecycle"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Handle connection states"}),": Provide feedback to users about connection status"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clean up properly"}),": Always remove listeners and end connections"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// \u2705 Good: Using useIAP hook\nfunction MyApp() {\n  const {connected, products, getProducts} = useIAP();\n\n  useEffect(() => {\n    if (connected) {\n      getProducts({skus: productIds});\n    }\n  }, [connected]);\n\n  return <AppContent />;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"-dont",children:"\u274c Don't:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialize and end repeatedly"}),": Don't call initConnection/endConnection for every operation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ignore connection state"}),": Don't attempt store operations when disconnected"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forget cleanup"}),": Always clean up listeners to prevent memory leaks"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// \u274c Bad: Initializing for every operation\nconst badPurchaseFlow = async (productId) => {\n  await initConnection(); // Don't do this\n  await requestPurchase({sku: productId});\n  await endConnection(); // Don't do this\n};\n\n// \u2705 Good: Use existing connection\nconst goodPurchaseFlow = async (productId) => {\n  if (connected) {\n    await requestPurchase({sku: productId});\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"purchase-flow-best-practices",children:"Purchase Flow Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"receipt-validation-and-security",children:"Receipt Validation and Security"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Server-side receipt validation is recommended"}),": For production apps, it's highly recommended to validate receipts on your secure server before granting access to content or features. See ",(0,i.jsx)(n.a,{href:"https://developer.apple.com/documentation/storekit/in-app_purchase/validating_receipts_with_the_app_store",children:"Apple's receipt validation guide"})," and ",(0,i.jsx)(n.a,{href:"https://developer.android.com/google/play/billing/security#verify",children:"Google Play's verification guide"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Finish transactions after validation"}),": Always call ",(0,i.jsx)(n.code,{children:"finishTransaction"})," after successfully validating a purchase on your server. Failing to do so will cause the purchase to remain in a pending state and may trigger repeated purchase prompts."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Never trust client-side data"}),": Always validate receipts server-side before granting premium content or features."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"purchase-state-management",children:"Purchase State Management"}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handle all purchase states"}),": Including pending, failed, restored, and cancelled purchases. Each state requires different handling logic."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handle pending purchases"}),": Some purchases may require approval (e.g., parental consent) and remain in pending state for extended periods."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Restore purchases properly"}),": Implement purchase restoration for non-consumable products and subscriptions. This is required by app store guidelines."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"error-handling-and-user-experience",children:"Error Handling and User Experience"}),"\n",(0,i.jsxs)(n.ol,{start:"7",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Implement comprehensive error handling"}),": Provide meaningful feedback to users for different error scenarios including network errors, cancelled purchases, and validation failures."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Graceful degradation"}),": Your app should work even if purchases fail or the store is unavailable. Don't block core functionality."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"User feedback"}),": Keep users informed about purchase status with appropriate loading states and success/error messages."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"testing-and-development",children:"Testing and Development"}),"\n",(0,i.jsxs)(n.ol,{start:"10",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test thoroughly"}),": Use real devices and official test accounts. In-app purchases don't work in simulators/emulators."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Monitor purchase flow"}),": Log important events for debugging, but never log sensitive information like receipts or tokens."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Check server-side validation libraries"}),": Consider using open-source libraries like ",(0,i.jsx)(n.a,{href:"https://github.com/ladeiko/node-app-store-receipt-verify",children:"node-app-store-receipt-verify"})," for iOS or ",(0,i.jsx)(n.a,{href:"https://github.com/macklinu/google-play-billing-validator",children:"google-play-billing-validator"})," for Android."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,i.jsx)(n.h3,{id:"transaction-management-issues",children:"Transaction Management Issues"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Not finishing transactions"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Wrong - forgetting to finish transaction\nconst handlePurchase = async (purchase) => {\n  await validateReceipt(purchase);\n  // Missing: finishTransaction call\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Always finish transactions after validation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Correct - always finish transaction\nconst handlePurchase = async (purchase) => {\n  const isValid = await validateReceipt(purchase);\n  if (isValid) {\n    await finishTransaction({purchase, isConsumable: true});\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"security-issues",children:"Security Issues"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Trusting client-side validation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Wrong - never trust client-side validation alone\nconst handlePurchase = async (purchase) => {\n  // This is not secure for production\n  grantPremiumFeature();\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Always validate server-side"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Correct - validate on secure server\nconst handlePurchase = async (purchase) => {\n  const isValid = await yourAPI.validateReceipt(purchase.transactionReceipt);\n  if (isValid) {\n    grantPremiumFeature();\n    await finishTransaction({purchase});\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"development-and-testing-issues",children:"Development and Testing Issues"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Testing on simulators"}),": In-app purchases only work on real devices with proper app store configurations."]}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Ignoring error codes"}),": Different errors require different handling strategies."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Proper error handling"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Correct - handle different error types appropriately\nconst handlePurchaseError = (error) => {\n  switch (error.code) {\n    case 'E_USER_CANCELLED':\n      // Silent - user intentionally cancelled\n      break;\n    case 'E_NETWORK_ERROR':\n      showRetryDialog();\n      break;\n    case 'E_ITEM_UNAVAILABLE':\n      showUnavailableMessage();\n      break;\n    default:\n      showGenericErrorMessage();\n      break;\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"app-lifecycle-issues",children:"App Lifecycle Issues"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Not handling app crashes"}),": Purchases can complete after app restart, so always check for pending purchases on app launch."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Handle background purchases"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Correct - check for purchases on app launch\nuseEffect(() => {\n  const checkPendingPurchases = async () => {\n    if (connected) {\n      // Check for any purchases that completed while app was closed\n      const purchases = await getAvailablePurchases();\n      for (const purchase of purchases) {\n        await processPurchase(purchase);\n      }\n    }\n  };\n\n  checkPendingPurchases();\n}, [connected]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"connection-management-issues",children:"Connection Management Issues"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Initializing connection repeatedly"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Wrong - don't initialize for every operation\nconst purchaseProduct = async (sku) => {\n  await initConnection(); // Don't do this\n  await requestPurchase({sku});\n  await endConnection(); // Don't do this\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Maintain single connection"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Correct - use existing connection\nconst purchaseProduct = async (sku) => {\n  if (connected) {\n    await requestPurchase({sku});\n  } else {\n    console.error('Store not connected');\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Review ",(0,i.jsx)(n.a,{href:"./purchases",children:"Purchase Implementation Guide"})," for detailed code examples"]}),"\n",(0,i.jsxs)(n.li,{children:["Check out ",(0,i.jsx)(n.a,{href:"./troubleshooting",children:"Error Handling Guide"})," for debugging tips"]}),"\n",(0,i.jsxs)(n.li,{children:["Explore ",(0,i.jsx)(n.a,{href:"../examples/complete-impl",children:"Complete Store Example"})," for production-ready code"]}),"\n",(0,i.jsxs)(n.li,{children:["See ",(0,i.jsx)(n.a,{href:"../api/",children:"API Reference"})," for detailed method documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8028:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/lifecycle-882aa01ea00089e05a08f19581d9b349.svg"},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function c(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);