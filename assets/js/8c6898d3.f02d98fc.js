"use strict";(self.webpackChunkexpo_iap_docs=self.webpackChunkexpo_iap_docs||[]).push([[1006],{571:(e,n,s)=>{s.d(n,{A:()=>a});var r=s(6540),i=s(4848);function t({className:e="adfit",style:n,unit:s,height:t,width:a}){return(0,r.useEffect)(()=>{const n=setTimeout(()=>{const n=document.querySelector(`.${e}`);if(!n)return void console.warn(`AdFit: Element with class "${e}" not found`);const r=n.querySelectorAll(".kakao_ad_area"),i=n.querySelectorAll('script[src*="kas/static/ba.min.js"]');r.forEach(e=>e.remove()),i.forEach(e=>e.remove());const o=document.createElement("ins"),c=document.createElement("script");o.className="kakao_ad_area",o.style.cssText="display:none; width:100%;",c.async=!0,c.type="text/javascript",c.src="//t1.daumcdn.net/kas/static/ba.min.js",o.setAttribute("data-ad-width",a.toString()),o.setAttribute("data-ad-height",t.toString()),o.setAttribute("data-ad-unit",s),n.appendChild(o),n.appendChild(c)},100);return()=>clearTimeout(n)},[e,s,t,a]),(0,i.jsx)("div",{style:n,children:(0,i.jsx)("div",{className:e})})}function a(){return(0,i.jsx)(t,{unit:"DAN-YTmjDwlbcP42HBg6",height:100,width:320,className:"adfit-top",style:{flex:1,marginTop:24,marginBottom:24}})}},5241:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"guides/purchases","title":"Purchases","description":"Purchase Flow Redesign","source":"@site/versioned_docs/version-2.6/guides/purchases.md","sourceDirName":"guides","slug":"/guides/purchases","permalink":"/docs/2.6/guides/purchases","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/expo-iap/tree/main/docs/versioned_docs/version-2.6/guides/purchases.md","tags":[],"version":"2.6","sidebarPosition":2,"frontMatter":{"title":"Purchases","sidebar_label":"Purchases","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Android Setup","permalink":"/docs/2.6/getting-started/setup-android"},"next":{"title":"Lifecycle","permalink":"/docs/2.6/guides/lifecycle"}}');var i=s(4848),t=s(8453),a=s(571);const o={title:"Purchases",sidebar_label:"Purchases",sidebar_position:2},c="Purchases",u={},d=[{value:"Purchase Flow Overview",id:"purchase-flow-overview",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Basic Purchase Flow",id:"basic-purchase-flow",level:2},{value:"1. Setup Purchase Listeners",id:"1-setup-purchase-listeners",level:3},{value:"2. Using with Hooks (Recommended)",id:"2-using-with-hooks-recommended",level:3},{value:"3. Request a Purchase",id:"3-request-a-purchase",level:3},{value:"New Platform-Specific API (v2.7.0+)",id:"new-platform-specific-api-v270",level:3},{value:"Legacy API (Still Supported)",id:"legacy-api-still-supported",level:3},{value:"New Subscription API (v2.7.0+)",id:"new-subscription-api-v270",level:3},{value:"Legacy Subscription API",id:"legacy-subscription-api",level:3},{value:"Important Notes",id:"important-notes",level:2},{value:"Purchase Flow Best Practices",id:"purchase-flow-best-practices",level:3},{value:"Pending Purchases",id:"pending-purchases",level:3},{value:"Getting Product Information",id:"getting-product-information",level:2},{value:"Retrieving Product Prices",id:"retrieving-product-prices",level:3},{value:"Platform Support",id:"platform-support",level:2},{value:"Checking Platform Compatibility",id:"checking-platform-compatibility",level:3},{value:"Product Types",id:"product-types",level:2},{value:"Consumable Products",id:"consumable-products",level:3},{value:"Non-Consumable Products",id:"non-consumable-products",level:3},{value:"Subscriptions",id:"subscriptions",level:3},{value:"Advanced Purchase Handling",id:"advanced-purchase-handling",level:2},{value:"Purchase Restoration",id:"purchase-restoration",level:3},{value:"Handling Pending Purchases",id:"handling-pending-purchases",level:3},{value:"Subscription Management",id:"subscription-management",level:3},{value:"Checking Subscription Status",id:"checking-subscription-status",level:4},{value:"Managing Subscriptions",id:"managing-subscriptions",level:4},{value:"Receipt Validation",id:"receipt-validation",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Testing Purchases",id:"testing-purchases",level:2},{value:"iOS Testing",id:"ios-testing",level:3},{value:"Android Testing",id:"android-testing",level:3},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"purchases",children:"Purchases"})}),"\n",(0,i.jsx)(a.A,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Purchase Flow Redesign"})," ","\u26a0\ufe0f"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"purchase"})," flow has been updated as a result of the findings in issue ",(0,i.jsx)(n.a,{href:"https://github.com/hyochan/react-native-iap/issues/307",children:"#307"}),". The resulting flow has been redesign to not rely on ",(0,i.jsx)(n.code,{children:"Promise"})," or ",(0,i.jsx)(n.code,{children:"Callback"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Below are some of the specific reasons for the redesign:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"There may be more than one response when requesting a payment."}),"\n",(0,i.jsxs)(n.li,{children:["Purchases are inter-session ",(0,i.jsx)(n.code,{children:"asynchronuous"})," meaning requests that are made may take several hours to complete and continue to exist even after the app has been closed or crashed."]}),"\n",(0,i.jsxs)(n.li,{children:["The purchase may be pending and hard to track what has been done (for ",(0,i.jsx)(n.a,{href:"https://github.com/hyochan/react-native-iap/issues/307",children:"example"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["The Billing Flow is an ",(0,i.jsx)(n.code,{children:"event"})," pattern rather than a ",(0,i.jsx)(n.code,{children:"callback"})," pattern."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For a comprehensive understanding of the purchase lifecycle, see our ",(0,i.jsx)(n.a,{href:"./lifecycle",children:"Purchase Lifecycle Guide"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"purchase-flow-overview",children:"Purchase Flow Overview"}),"\n",(0,i.jsxs)(n.p,{children:["Once you have called ",(0,i.jsx)(n.code,{children:"getProducts()"}),", and have a valid response, you can call ",(0,i.jsx)(n.code,{children:"requestPurchase()"}),". Subscribable products can be purchased just like consumable products and users can cancel subscriptions by using the iOS System Settings."]}),"\n",(0,i.jsxs)(n.p,{children:["Before you request any purchase, you should set ",(0,i.jsx)(n.code,{children:"purchaseUpdatedListener"})," from ",(0,i.jsx)(n.code,{children:"expo-iap"}),". It is recommended that you start listening to updates as soon as your application launches. And don't forget that even at launch you may receive successful purchases that either completed while your app was closed or that failed to be finished, consumed or acknowledged due to network errors or bugs."]}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event-driven"}),": Purchases are handled through events rather than promises"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous"}),": Purchases may complete after your app is closed or crashed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation required"}),": Always validate receipts on your server"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State management"}),": Use the ",(0,i.jsx)(n.code,{children:"useIAP"})," hook for automatic state management"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-purchase-flow",children:"Basic Purchase Flow"}),"\n",(0,i.jsx)(n.h3,{id:"1-setup-purchase-listeners",children:"1. Setup Purchase Listeners"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {\n  initConnection,\n  purchaseErrorListener,\n  purchaseUpdatedListener,\n  type ProductPurchase,\n  type PurchaseError,\n  finishTransaction,\n} from 'expo-iap';\n\nclass App extends Component {\n  purchaseUpdateSubscription = null;\n  purchaseErrorSubscription = null;\n\n  componentDidMount() {\n    initConnection().then(() => {\n      this.purchaseUpdateSubscription = purchaseUpdatedListener(\n            (purchase: ProductPurchase) => {\n              console.log('purchaseUpdatedListener', purchase);\n              this.handlePurchaseUpdate(purchase);\n            },\n          );\n\n          this.purchaseErrorSubscription = purchaseErrorListener(\n            (error: PurchaseError) => {\n              console.log('purchaseErrorListener', error);\n              this.handlePurchaseError(error);\n            },\n          );\n        });\n    });\n  }\n\n  componentWillUnmount() {\n    if (this.purchaseUpdateSubscription) {\n      this.purchaseUpdateSubscription.remove();\n      this.purchaseUpdateSubscription = null;\n    }\n    if (this.purchaseErrorSubscription) {\n      this.purchaseErrorSubscription.remove();\n      this.purchaseErrorSubscription = null;\n    }\n  }\n\n  handlePurchaseUpdate = (purchase: ProductPurchase) => {\n    const receipt = purchase.transactionReceipt;\n    if (receipt) {\n      yourAPI\n        .deliverOrDownloadFancyInAppPurchase(purchase.transactionReceipt)\n        .then(async (deliveryResult) => {\n          if (isSuccess(deliveryResult)) {\n            // Tell the store that you have delivered what has been paid for.\n            // Failure to do this will result in the purchase being refunded on Android and\n            // the purchase event will reappear on every relaunch of the app until you succeed\n            // in doing the below. It will also be impossible for the user to purchase consumables\n            // again until you do this.\n\n            // If consumable (can be purchased again)\n            await finishTransaction({purchase, isConsumable: true});\n            // If not consumable\n            await finishTransaction({purchase, isConsumable: false});\n          } else {\n            // Retry / conclude the purchase is fraudulent, etc.\n          }\n        });\n    }\n  };\n\n  handlePurchaseError = (error: PurchaseError) => {\n    console.warn('purchaseErrorListener', error);\n  };\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-using-with-hooks-recommended",children:"2. Using with Hooks (Recommended)"}),"\n",(0,i.jsx)(n.p,{children:"For a more modern approach using React hooks, here's a comprehensive implementation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import React, {useEffect, useState, useCallback} from 'react';\nimport {Platform, Alert, InteractionManager} from 'react-native';\nimport {useIAP} from 'expo-iap';\n\n// Define your product SKUs\nconst bulbPackSkus = ['dev.hyo.martie.10bulbs', 'dev.hyo.martie.30bulbs'];\nconst subscriptionSkus = ['dev.hyo.martie.premium'];\n\nexport default function PurchaseScreen() {\n  const {\n    connected,\n    products,\n    subscriptions,\n    currentPurchase,\n    currentPurchaseError,\n    getProducts,\n    getSubscriptions,\n    requestPurchase,\n    finishTransaction,\n    validateReceipt,\n  } = useIAP();\n\n  const [isLoading, setIsLoading] = useState(false);\n  const [isReady, setIsReady] = useState(false);\n\n  // Initialize products when IAP connection is established\n  useEffect(() => {\n    if (!connected) return;\n\n    const initializeIAP = async () => {\n      try {\n        // Get both products and subscriptions\n        await getProducts(bulbPackSkus);\n        await getSubscriptions(subscriptionSkus);\n        setIsReady(true);\n      } catch (error) {\n        console.error('Error initializing IAP:', error);\n      }\n    };\n\n    initializeIAP();\n  }, [connected, getProducts, getSubscriptions]);\n\n  // Validate receipt helper\n  const handleValidateReceipt = useCallback(\n    async (sku: string, purchase: any) => {\n      try {\n        if (Platform.OS === 'ios') {\n          return await validateReceipt(sku);\n        } else if (Platform.OS === 'android') {\n          const purchaseToken = purchase.purchaseTokenAndroid;\n          const packageName =\n            purchase.packageNameAndroid || 'your.package.name';\n          const isSub = subscriptionSkus.includes(sku);\n\n          return await validateReceipt(sku, {\n            packageName,\n            productToken: purchaseToken,\n            isSub,\n          });\n        }\n        return {isValid: true}; // Default for unsupported platforms\n      } catch (error) {\n        console.error('Receipt validation failed:', error);\n        return {isValid: false};\n      }\n    },\n    [validateReceipt],\n  );\n\n  // Handle successful purchases\n  useEffect(() => {\n    if (currentPurchase) {\n      handlePurchaseUpdate(currentPurchase);\n    }\n  }, [currentPurchase]);\n\n  // Handle purchase errors\n  useEffect(() => {\n    if (currentPurchaseError) {\n      setIsLoading(false);\n\n      // Don't show error for user cancellation\n      if (currentPurchaseError.code === 'E_USER_CANCELLED') {\n        return;\n      }\n\n      Alert.alert(\n        'Purchase Error',\n        'Failed to complete purchase. Please try again.',\n      );\n      console.error('Purchase error:', currentPurchaseError);\n    }\n  }, [currentPurchaseError]);\n\n  const handlePurchaseUpdate = async (purchase: any) => {\n    try {\n      setIsLoading(true);\n      console.log('Processing purchase:', purchase);\n\n      const productId = purchase.id;\n\n      // Validate receipt on your server\n      const validationResult = await handleValidateReceipt(productId, purchase);\n\n      if (validationResult.isValid) {\n        // Determine if this is a consumable product\n        const isConsumable = bulbPackSkus.includes(productId);\n\n        // Finish the transaction\n        await finishTransaction({\n          purchase,\n          isConsumable, // Set to true for consumable products\n        });\n\n        // Record purchase in your database\n        await recordPurchaseInDatabase(purchase, productId);\n\n        // Update local state (e.g., add bulbs, enable premium features)\n        await updateLocalState(productId);\n\n        // Show success message\n        showSuccessMessage(productId);\n      } else {\n        Alert.alert(\n          'Validation Error',\n          'Purchase could not be validated. Please contact support.',\n        );\n      }\n    } catch (error) {\n      console.error('Error handling purchase:', error);\n      Alert.alert('Error', 'Failed to process purchase.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Request purchase for products\n  const handlePurchaseBulbs = async (productId: string) => {\n    if (!connected) {\n      Alert.alert(\n        'Not Connected',\n        'Store connection unavailable. Please try again later.',\n      );\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n\n      if (Platform.OS === 'ios') {\n        // iOS: single product purchase\n        await requestPurchase({\n          request: {\n            sku: productId,\n            andDangerouslyFinishTransactionAutomatically: false,\n          },\n        });\n      } else {\n        // Android: array of products (even for single purchase)\n        await requestPurchase({\n          request: {skus: [productId]},\n        });\n      }\n    } catch (error) {\n      setIsLoading(false);\n      console.error('Purchase request failed:', error);\n    }\n  };\n\n  // Request purchase for subscriptions\n  const handlePurchaseSubscription = async (subscriptionId: string) => {\n    if (!connected) {\n      Alert.alert(\n        'Not Connected',\n        'Store connection unavailable. Please try again later.',\n      );\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n\n      if (Platform.OS === 'ios') {\n        await requestPurchase({\n          request: {sku: subscriptionId},\n          type: 'subs',\n        });\n      } else if (Platform.OS === 'android') {\n        // Find subscription to get offer details\n        const subscription = subscriptions.find((s) => s.id === subscriptionId);\n\n        if (subscription?.subscriptionOfferDetails?.length > 0) {\n          const subscriptionOffers = subscription.subscriptionOfferDetails.map(\n            (offer) => ({\n              sku: subscriptionId,\n              offerToken: offer.offerToken,\n            }),\n          );\n\n          await requestPurchase({\n            request: {\n              skus: [subscriptionId],\n              subscriptionOffers,\n            },\n            type: 'subs',\n          });\n        } else {\n          // Fallback for subscriptions without offers\n          await requestPurchase({\n            request: {\n              skus: [subscriptionId],\n              subscriptionOffers: [{sku: subscriptionId, offerToken: ''}],\n            },\n            type: 'subs',\n          });\n        }\n      }\n    } catch (error) {\n      setIsLoading(false);\n      console.error('Subscription request failed:', error);\n    }\n  };\n\n  const recordPurchaseInDatabase = async (purchase: any, productId: string) => {\n    // Implement your database recording logic here\n    console.log('Recording purchase in database:', {purchase, productId});\n  };\n\n  const updateLocalState = async (productId: string) => {\n    // Update your local app state based on the purchase\n    if (bulbPackSkus.includes(productId)) {\n      // Add bulbs to user's account\n      const bulbCount = productId.includes('10bulbs') ? 10 : 30;\n      console.log(`Adding ${bulbCount} bulbs to user account`);\n    } else if (subscriptionSkus.includes(productId)) {\n      // Enable premium features\n      console.log('Enabling premium features');\n    }\n  };\n\n  const showSuccessMessage = (productId: string) => {\n    InteractionManager.runAfterInteractions(() => {\n      if (bulbPackSkus.includes(productId)) {\n        const bulbCount = productId.includes('10bulbs') ? 10 : 30;\n        Alert.alert(\n          'Thank You!',\n          `${bulbCount} bulbs have been added to your account.`,\n        );\n      } else if (subscriptionSkus.includes(productId)) {\n        Alert.alert(\n          'Thank You!',\n          'Premium subscription activated successfully.',\n        );\n      }\n    });\n  };\n\n  return (\n    <View>\n      {/* Your purchase UI components */}\n      <Text>Connection Status: {connected ? 'Connected' : 'Disconnected'}</Text>\n      <Text>Products Ready: {isReady ? 'Yes' : 'No'}</Text>\n      {/* Add your purchase buttons and UI here */}\n    </View>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-request-a-purchase",children:"3. Request a Purchase"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Important Platform Difference:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"iOS"}),": Can only purchase one product at a time (single SKU)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Android"}),": Can purchase multiple products at once (array of SKUs)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This fundamental difference requires platform-specific handling. Starting from v2.7.0, we provide a cleaner API:"}),"\n",(0,i.jsx)(n.h3,{id:"new-platform-specific-api-v270",children:"New Platform-Specific API (v2.7.0+)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {requestPurchase} from 'expo-iap';\n\n// Cleaner approach with platform-specific parameters\nconst handleBuyProduct = async (productId: string) => {\n  try {\n    await requestPurchase({\n      request: {\n        ios: {\n          sku: productId,\n          appAccountToken: 'user-123', // Optional: for server-side validation\n        },\n        android: {\n          skus: [productId],\n          obfuscatedAccountIdAndroid: 'user-123', // Optional: user identifier\n        },\n      },\n    });\n  } catch (err) {\n    console.warn(err.code, err.message);\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"legacy-api-still-supported",children:"Legacy API (Still Supported)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {requestPurchase, Platform} from 'expo-iap';\n\n// For regular products (consumables/non-consumables)\nconst handleBuyProduct = async (productId) => {\n  try {\n    if (Platform.OS === 'ios') {\n      // iOS: single product purchase\n      await requestPurchase({\n        request: {sku: productId},\n      });\n    } else if (Platform.OS === 'android') {\n      // Android: array of products (even for single purchase)\n      await requestPurchase({\n        request: {skus: [productId]},\n      });\n    }\n  } catch (err) {\n    console.warn(err.code, err.message);\n  }\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For subscriptions, the platform differences are even more significant:"})}),"\n",(0,i.jsx)(n.h3,{id:"new-subscription-api-v270",children:"New Subscription API (v2.7.0+)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const handleBuySubscription = async (subscriptionId: string) => {\n  try {\n    // Find the subscription product to get offer details (Android)\n    const subscription = subscriptions.find((s) => s.id === subscriptionId);\n\n    await requestPurchase({\n      request: {\n        ios: {\n          sku: subscriptionId,\n          appAccountToken: 'user-123', // Optional: for server-side validation\n        },\n        android: {\n          skus: [subscriptionId],\n          subscriptionOffers:\n            subscription?.subscriptionOfferDetails?.map((offer) => ({\n              sku: subscriptionId,\n              offerToken: offer.offerToken,\n            })) || [],\n          obfuscatedAccountIdAndroid: 'user-123', // Optional: user identifier\n        },\n      },\n      type: 'subs',\n    });\n  } catch (err) {\n    console.warn(err.code, err.message);\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"legacy-subscription-api",children:"Legacy Subscription API"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const handleBuySubscription = async (subscriptionId: string) => {\n  try {\n    if (Platform.OS === 'ios') {\n      await requestPurchase({\n        request: {sku: subscriptionId},\n        type: 'subs',\n      });\n    } else if (Platform.OS === 'android') {\n      // Find the subscription product to get its offer details\n      const subscription = subscriptions.find((s) => s.id === subscriptionId);\n\n      if (!subscription) {\n        throw new Error(`Subscription with ID ${subscriptionId} not found`);\n      }\n\n      // Check if the subscription has offer details\n      if (subscription.subscriptionOfferDetails?.length > 0) {\n        // Android requires offerToken for each subscription SKU\n        // Use the first available offer or let user choose\n        const firstOffer = subscription.subscriptionOfferDetails[0];\n        const subscriptionOffers = [\n          {\n            sku: subscriptionId,\n            offerToken: firstOffer.offerToken,\n          },\n        ];\n\n        await requestPurchase({\n          request: {\n            skus: [subscriptionId],\n            subscriptionOffers, // Required: Must match number of SKUs\n          },\n          type: 'subs',\n        });\n      } else {\n        // This should not happen with properly configured subscriptions\n        throw new Error('No subscription offers available');\n      }\n    }\n  } catch (err) {\n    console.warn(err.code, err.message);\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,i.jsx)(n.h3,{id:"purchase-flow-best-practices",children:"Purchase Flow Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Always set up listeners first"}),": Set up ",(0,i.jsx)(n.code,{children:"purchaseUpdatedListener"})," and ",(0,i.jsx)(n.code,{children:"purchaseErrorListener"})," before making any purchase requests."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handle pending purchases"}),": On app launch, check for pending purchases that may have completed while the app was closed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Never rely on promises"}),": The purchase flow is event-driven, not promise-based. Always use listeners to handle purchase results."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Validate receipts server-side"}),": Never trust client-side validation. Always validate receipts on your secure server."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Finish transactions"}),": Always call ",(0,i.jsx)(n.code,{children:"finishTransaction"})," after successful validation to complete the purchase."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pending-purchases",children:"Pending Purchases"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// On app initialization\ncomponentDidMount() {\n  initConnection().then(() => {\n    // Set up purchase listeners\n    // Note: expo-iap handles pending purchases automatically\n    this.setupPurchaseListeners();\n  });\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"getting-product-information",children:"Getting Product Information"}),"\n",(0,i.jsx)(n.h3,{id:"retrieving-product-prices",children:"Retrieving Product Prices"}),"\n",(0,i.jsx)(n.p,{children:"Here's how to get product prices across platforms:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Get product price by ID with proper platform checking\nconst getProductPrice = (productId: string): string => {\n  if (!isReady || products.length === 0) {\n    return Platform.OS === 'ios' ? '$0.99' : '\u20a91,200'; // Default prices\n  }\n\n  const product = products.find((p) => p.id === productId);\n  if (!product) return Platform.OS === 'ios' ? '$0.99' : '\u20a91,200';\n\n  if (Platform.OS === 'ios') {\n    return product.displayPrice || '$0.99';\n  } else {\n    // Android\n    const androidProduct = product as ProductAndroid;\n    return (\n      androidProduct.oneTimePurchaseOfferDetails?.formattedPrice || '\u20a91,200'\n    );\n  }\n};\n\n// Get subscription price by ID with proper platform checking\nconst getSubscriptionPrice = (subscriptionId: string): string => {\n  if (!isReady || subscriptions.length === 0) {\n    return Platform.OS === 'ios' ? '$9.99' : '\u20a911,000'; // Default prices\n  }\n\n  const subscription = subscriptions.find((s) => s.id === subscriptionId);\n  if (!subscription) return Platform.OS === 'ios' ? '$9.99' : '\u20a911,000';\n\n  if (Platform.OS === 'ios') {\n    return subscription.displayPrice || '$9.99';\n  } else {\n    // Android\n    const androidSubscription = subscription as ProductAndroid;\n    if (androidSubscription.subscriptionOfferDetails?.length > 0) {\n      const firstOffer = androidSubscription.subscriptionOfferDetails[0];\n      if (firstOffer.pricingPhases.pricingPhaseList.length > 0) {\n        return (\n          firstOffer.pricingPhases.pricingPhaseList[0].formattedPrice ||\n          '\u20a911,000'\n        );\n      }\n    }\n    return '\u20a911,000'; // Default Android price\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"platform-support",children:"Platform Support"}),"\n",(0,i.jsx)(n.h3,{id:"checking-platform-compatibility",children:"Checking Platform Compatibility"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// Define supported platforms\nconst SUPPORTED_PLATFORMS = ['ios', 'android'];\n\nexport default function PurchaseScreen() {\n  const isPlatformSupported = SUPPORTED_PLATFORMS.includes(Platform.OS);\n\n  if (!isPlatformSupported) {\n    return (\n      <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>\n        <Text>Platform Not Supported</Text>\n        <Text>In-app purchases are only available on iOS and Android.</Text>\n      </View>\n    );\n  }\n\n  // Rest of your purchase implementation\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"product-types",children:"Product Types"}),"\n",(0,i.jsx)(n.h3,{id:"consumable-products",children:"Consumable Products"}),"\n",(0,i.jsx)(n.p,{children:"Consumable products can be purchased multiple times (e.g., coins, gems):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const buyConsumable = async (productId) => {\n  await requestPurchase({sku: productId});\n  // After successful validation and finishing transaction,\n  // the product can be purchased again\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"non-consumable-products",children:"Non-Consumable Products"}),"\n",(0,i.jsx)(n.p,{children:"Non-consumable products are purchased once and remain available (e.g., premium features):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const buyNonConsumable = async (productId) => {\n  await requestPurchase({sku: productId});\n  // After purchase, check availablePurchases to restore\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"subscriptions",children:"Subscriptions"}),"\n",(0,i.jsx)(n.p,{children:"Subscriptions require special handling on Android due to the offer token requirement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const buySubscription = async (subscriptionId: string) => {\n  if (Platform.OS === 'ios') {\n    // iOS: Simple SKU-based purchase\n    await requestPurchase({\n      request: {sku: subscriptionId},\n      type: 'subs',\n    });\n  } else {\n    // Android: Requires offerToken for each subscription\n    const subscription = subscriptions.find((s) => s.id === subscriptionId);\n\n    if (!subscription?.subscriptionOfferDetails?.length) {\n      throw new Error('No subscription offers available');\n    }\n\n    // Use the first available offer (or let user choose)\n    const firstOffer = subscription.subscriptionOfferDetails[0];\n\n    await requestPurchase({\n      request: {\n        skus: [subscriptionId],\n        subscriptionOffers: [\n          {\n            sku: subscriptionId,\n            offerToken: firstOffer.offerToken, // Required!\n          },\n        ],\n      },\n      type: 'subs',\n    });\n  }\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Important Android Notes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each subscription SKU must have a corresponding offerToken"}),"\n",(0,i.jsx)(n.li,{children:"The number of SKUs must match the number of offerTokens"}),"\n",(0,i.jsxs)(n.li,{children:["offerToken comes from ",(0,i.jsx)(n.code,{children:"subscriptionOfferDetails"})," in the product details"]}),"\n",(0,i.jsx)(n.li,{children:'Without offerToken, you\'ll get: "The number of skus must match the number of offerTokens"'}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"advanced-purchase-handling",children:"Advanced Purchase Handling"}),"\n",(0,i.jsx)(n.h3,{id:"purchase-restoration",children:"Purchase Restoration"}),"\n",(0,i.jsx)(n.p,{children:"For non-consumable products and subscriptions, implement purchase restoration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const {getAvailablePurchases} = useIAP();\n\nconst restorePurchases = async () => {\n  try {\n    const purchases = await getAvailablePurchases();\n\n    for (const purchase of purchases) {\n      // Validate and restore each purchase\n      const isValid = await validateReceiptOnServer(purchase);\n      if (isValid) {\n        await grantPurchaseToUser(purchase);\n      }\n    }\n  } catch (error) {\n    console.error('Failed to restore purchases:', error);\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handling-pending-purchases",children:"Handling Pending Purchases"}),"\n",(0,i.jsx)(n.p,{children:"Some purchases may be in a pending state (e.g., awaiting parental approval):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"useEffect(() => {\n  if (currentPurchase?.purchaseState === 'pending') {\n    // Inform user that purchase is pending\n    showPendingPurchaseMessage();\n  }\n}, [currentPurchase]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"subscription-management",children:"Subscription Management"}),"\n",(0,i.jsx)(n.h4,{id:"checking-subscription-status",children:"Checking Subscription Status"}),"\n",(0,i.jsx)(n.p,{children:"Platform-specific properties are available to check if a subscription is active:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const isSubscriptionActive = (purchase: Purchase): boolean => {\n  const currentTime = Date.now();\n\n  if (Platform.OS === 'ios') {\n    // iOS: Check expiration date\n    if (purchase.expirationDateIos) {\n      // expirationDateIos is in milliseconds\n      return purchase.expirationDateIos > currentTime;\n    }\n\n    // For Sandbox environment, consider recent purchases as active\n    if (purchase.environmentIOS === 'Sandbox') {\n      const dayInMs = 24 * 60 * 60 * 1000;\n      return (\n        purchase.transactionDate &&\n        currentTime - purchase.transactionDate < dayInMs\n      );\n    }\n  } else if (Platform.OS === 'android') {\n    // Android: Check auto-renewal status\n    if (purchase.autoRenewingAndroid !== undefined) {\n      return purchase.autoRenewingAndroid;\n    }\n\n    // Check purchase state (0 = purchased, 1 = canceled)\n    if (purchase.purchaseStateAndroid === 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Properties for Subscription Status:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"iOS"}),": ",(0,i.jsx)(n.code,{children:"expirationDateIos"})," - Unix timestamp when subscription expires"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Android"}),": ",(0,i.jsx)(n.code,{children:"autoRenewingAndroid"})," - Boolean indicating if subscription will renew"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"managing-subscriptions",children:"Managing Subscriptions"}),"\n",(0,i.jsx)(n.p,{children:"Provide users with subscription management options:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {deepLinkToSubscriptions} from 'expo-iap';\n\nconst openSubscriptionManagement = () => {\n  // This opens the platform-specific subscription management UI\n  deepLinkToSubscriptions();\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"receipt-validation",children:"Receipt Validation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Important Platform Differences for Receipt Validation:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"iOS"}),": Only requires the SKU for validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Android"}),": Requires additional parameters including ",(0,i.jsx)(n.code,{children:"packageName"}),", ",(0,i.jsx)(n.code,{children:"productToken"}),", and optionally ",(0,i.jsx)(n.code,{children:"accessToken"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Always validate receipts on your server for security and fraud prevention."})," Client-side validation is not sufficient for production apps."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const handleValidateReceipt = useCallback(\n  async (sku: string, purchase: any) => {\n    try {\n      if (Platform.OS === 'ios') {\n        // iOS: Simple validation with just SKU\n        return await validateReceipt(sku);\n      } else if (Platform.OS === 'android') {\n        // Android: Requires additional validation parameters\n        const purchaseToken = purchase.purchaseTokenAndroid;\n        const packageName = purchase.packageNameAndroid || 'your.package.name';\n        const isSub = subscriptionSkus.includes(sku);\n\n        // Check required Android parameters before validation\n        if (!purchaseToken || !packageName) {\n          throw new Error(\n            'Android validation requires packageName and productToken',\n          );\n        }\n\n        return await validateReceipt(sku, {\n          packageName,\n          productToken: purchaseToken,\n          isSub,\n          // accessToken may be required for server-side validation\n        });\n      }\n      return {isValid: true}; // Default for unsupported platforms\n    } catch (error) {\n      console.error('Receipt validation failed:', error);\n      return {isValid: false};\n    }\n  },\n  [validateReceipt],\n);\n\n// Use in purchase handler\nconst handlePurchaseUpdate = async (purchase: any) => {\n  try {\n    const productId = purchase.id;\n\n    // Validate receipt on your server\n    const validationResult = await handleValidateReceipt(productId, purchase);\n\n    if (validationResult.isValid) {\n      // Process the purchase\n      await finishTransaction({\n        purchase,\n        isConsumable: bulbPackSkus.includes(productId),\n      });\n\n      // Update user's purchase state in your app\n      updateUserPurchases(productId);\n    } else {\n      console.error('Receipt validation failed for:', productId);\n      // Handle invalid receipt\n    }\n  } catch (error) {\n    console.error('Purchase processing failed:', error);\n  }\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Best Practices:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always validate on your server, never trust client-side validation alone"}),"\n",(0,i.jsx)(n.li,{children:"Store purchase receipts in your database for future reference"}),"\n",(0,i.jsx)(n.li,{children:"Implement retry logic for failed validations due to network issues"}),"\n",(0,i.jsx)(n.li,{children:"Log validation failures for fraud detection and analysis"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"Implement comprehensive error handling for various scenarios:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const handlePurchaseError = (error) => {\n  switch (error.code) {\n    case 'E_USER_CANCELLED':\n      // User cancelled - no action needed\n      break;\n\n    case 'E_NETWORK_ERROR':\n      // Show retry option\n      showRetryDialog();\n      break;\n\n    case 'E_ITEM_UNAVAILABLE':\n      // Product not available\n      showProductUnavailableMessage();\n      break;\n\n    case 'E_ALREADY_OWNED':\n      // User already owns this product\n      showAlreadyOwnedMessage();\n      break;\n\n    default:\n      // Generic error handling\n      showGenericErrorMessage(error.message);\n      break;\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-purchases",children:"Testing Purchases"}),"\n",(0,i.jsx)(n.h3,{id:"ios-testing",children:"iOS Testing"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create sandbox accounts in App Store Connect"}),"\n",(0,i.jsx)(n.li,{children:"Sign out of App Store on device"}),"\n",(0,i.jsx)(n.li,{children:"Sign in with sandbox account when prompted during purchase"}),"\n",(0,i.jsx)(n.li,{children:"Test with TestFlight builds"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"android-testing",children:"Android Testing"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create test accounts in Google Play Console"}),"\n",(0,i.jsx)(n.li,{children:"Upload signed APK to internal testing track"}),"\n",(0,i.jsx)(n.li,{children:"Add test accounts to the testing track"}),"\n",(0,i.jsx)(n.li,{children:"Test with signed builds (not debug builds)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.p,{children:["For comprehensive information about purchase lifecycle management, best practices, and common pitfalls, see our detailed ",(0,i.jsx)(n.a,{href:"./lifecycle",children:"Purchase Lifecycle Guide"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Other helpful resources:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./troubleshooting",children:"Error Handling Guide"})," for debugging purchase issues"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../api/",children:"API Reference"})," for detailed method documentation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../examples/complete-impl",children:"Complete Store Example"})," for production-ready implementation"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);